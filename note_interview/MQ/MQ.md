# MQ

## 一、MQ 基础

### 1.1 为什么使用消息队列

**三大作用**

+ 解耦：传统的软件开发模式，各个模块之间相互调用，数据共享，每个模块都要时刻关注其他模块的是否更改或者是否挂掉等等，使用消息队列，可以避免模块之间直接调用，将所需共享的数据放在消息队列中，对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的可扩展性。
+ 异步：消息的发送和接收可以在不同的时间发生，而不需要立即同步。这有助于提升系统的响应速度和处理能力。例如，用户提交一个订单后，系统可以将订单信息放入消息队列中，然后由后台服务异步处理订单，而不必让用户等待订单处理完成。
+ 削峰：削峰指的是通过将请求或任务平滑地分布到一段时间内来避免瞬时负载过高。消息队列可以将瞬时的高负载任务放入队列中，并按照一定的速度逐步处理这些任务。这样，可以减少系统在高负载情况下的压力，保持系统的稳定性和性能。例如，在电商促销期间，高并发的订单请求可以通过消息队列逐步处理，从而避免系统的瞬时过载。

**我的项目：**

主要是实现一个延时发布的功能，其实是让业务实现了异步。使用了 direct 模式，用 TTL 和 死信队列实现 延迟上线的功能。



### 1.2 技术选型

选择中间件的可以从这些维度来考虑：可靠性，性能，功能，可运维行，可拓展 性，社区活跃度。目前常用的几个中间件，ActiveMQ作为“老古董”，市面上用的已 经不多，其它几种： RabbitMQ： 

+ 优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置 
+ 缺点：吞吐量不太理想，不易进行二次开发 

RocketMQ： 

+ 优点：性能好，高吞吐量，稳定可靠，有活跃的中文社区 
+ 缺点：兼容性上不是太好 

Kafka： 

+ 优点：拥有强大的性能及吞吐量，兼容性很好 
+ 缺点：响应延迟比较高 

我们的系统是面向用户的C端系统，具有一定的并发量，对性能也有比较高的要求， 所以选择了低延迟、吞吐量比较高，可用性比较好的RocketMQ。



## 二、Rabbit MQ

### 2.1 如何保证消息不丢失

RabbitMQ丢失消息分为如下几种情况：

1. **生产者丢消息**：

   生产者将数据发送到RabbitMQ的时候，可能在传输过程中因为网络等问题而将数据弄丢了。

2. **RabbitMQ自己丢消息**：

   Rabbit MQ 是基于内存的，和 Redis 一样，如果 Rabbit MQ 宕机，则消息队列里的所有数据都会丢失。

3. **消费端丢消息**：

   主要是因为消费者消费时，如果出现异常，这样你重启之后，RabbitMQ就认为你已经消费过了，然后就丢了数据。

针对上述三种情况，RabbitMQ可以采用如下方式避免消息丢失：

1. 生产者丢消息：

   - 可以选择使用RabbitMQ提供是事务功能，就是生产者在发送数据之前开启事务，然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会受到异常报错，这时就可以回滚事务，然后尝试重新发送。如果收到了消息，那么就可以提交事务。这种方式有明显的缺点，即RabbitMQ事务开启后，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降。
   - 可以开启confirm模式。在生产者那里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了RabbitMQ之中，RabbitMQ会给你回传一个ack消息，告诉你这个消息发送OK了。如果RabbitMQ没能处理这个消息，会回调一个nack接口，通知这个消息丢失了，可以进行重试。

   事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后RabbitMQ会回调告知成功与否。 一般在生产者这块避免丢失，都是用confirm机制。

2. RabbitMQ自己丢消息：

   要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。

   - 交换机持久化
   - 队列持久化
   - 消息持久化

3. 消费端丢消息：

   RabbitMQ是通过消费者回执来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。而SpringAMQP则允许配置三种确认模式：

   + manual：手动ack，需要在业务代码结束后，调用api发送ack。

   + auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack

   + none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除

   当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力。这时候我们可以使用**消费失败重试机制**，利用Spring的retry机制，在消费者出现异常时利用本地重试，当重试了几次都是失败后，就会按我们配置的失败策略执行。失败策略：

   - RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式

   - ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队

   - RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机

   

### 2.2 RabbitMQ消息的重复消费问题如何解决的

嗯，这个我们还真遇到过，是这样的，我们当时消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了

因为我们当时处理的支付（订单|业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了

**面试官**：那你还知道其他的解决方案吗？

**候选人**：

嗯，我想想~

其实这个就是典型的幂等的问题，比如，redis分布式锁、数据库的锁都是可以的

**面试官**：RabbitMQ中死信交换机 ? （RabbitMQ延迟队列有了解过嘛）

**候选人**：

嗯！了解过！

我们当时的xx项目有一个xx业务，需要用到延迟队列，其中就是使用RabbitMQ来实现的。

延迟队列就是用到了死信交换机和TTL（消息存活时间）实现的。

如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了。

我记得RabbitMQ还有一种方式可以实现延迟队列，在RabbitMQ中安装一个死信插件，这样更方便一些，我们只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超时时间就行了，相对于死信交换机+TTL要省略了一些步骤

**面试官**：如果有100万消息堆积在MQ , 如何解决 ?

**候选人**：

我在实际的开发中，没遇到过这种情况，不过，如果发生了堆积的问题，解决方案也所有很多的

第一:提高消费者的消费能力 ,可以使用多线程消费任务

第二：增加更多消费者，提高消费速度 

​			 使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息

第三：扩大队列容积，提高堆积上限 

可以使用RabbitMQ惰性队列，惰性队列的好处主要是

①接收到消息后直接存入磁盘而非内存

②消费者要消费消息时才会从磁盘中读取并加载到内存

③支持数百万条的消息存储

**面试官**：RabbitMQ的高可用机制有了解过嘛

**候选人**：

嗯，熟悉的~

我们当时项目在生产环境下，使用的集群，当时搭建是镜像模式集群，使用了3台机器。

镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失

**面试官**：那出现丢数据怎么解决呢？

**候选人**：

我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。

并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可