# Mysql

[TOC]

## 一、数据库基础



### Mysql 引擎

#### 介绍

1. `MyISAM`: B 树它的每个节点都是 Key.value 的二元组，它的 key 都是从左到右递增的排序，value 中存储数据。这种模式在读取数据方面的性能很高，因为有单独的索引文件，Myisam 的存 储文件有三个.frm 是表的结构文件，.MYD 是数据文件，.MYI 是索引文件。不过 Myisam 也 有些缺点它只支持表级锁，不支持行级锁也不支持事务，外键等，所以一般用于大数据存储
2. `InnoDB`: 这是 MySQL 5.6 以及之后的默认引擎。B+树。
3. `Memory`: 这是一个特殊的引擎，该引擎存取的数据，全部放在内存中，不会落入磁盘。因此当数据库宕机或重启后，数据就会丢失。自从 Redis 兴起之后，memory 引擎也式微了。





## 二、MySQL 基础

### 2.1 mysql 数据类型

### 2.2 mysql 的基础架构（一条sql的执行流程）

![img](https://raw.githubusercontent.com/Quinlan7/pic_cloud/main/img/202407181638067.png)

+ 先检查该语句 是否有权限 ，如果没有权限，直接返回错误信息，如果有权限会 先查询缓存 (MySQL8.0 版本以前)。 
+ 如果没有缓存，分析器进行语法分析 ，判断 sql 语句是否有语法错误。
+ 语法解析之后，优化器会对查询的语句进行优化，确定执行的方案。 
+ 完成查询优化后，执行器按照生成的执行计划 调用数据库引擎接口 ，返回执行结果。

### 2.3 mysql 存储引擎

#### 2.3.1 InnoDB 和 MyISAM 的区别

1. **事务支持**：MyISAM不提供事务支持；InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback) 事务的能力。并且，InnoDB 默认使⽤的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读 问题发生的（基于 MVCC 和 Next-Key Lock）
2. **最小锁粒度**：MyISAM只支持表级锁，更新时会锁住整张表，导致其它查询和更 新都会被阻塞。InnoDB支持行级锁。 
3. **索引类型**：数据结构都是B+树，但是MyISAM的索引为非聚簇索引，InnoDB的索引是聚簇索引。
4. **主键必需**：MyISAM允许没有任何索引和主键的表存在；InnoDB如果没有设定 主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主 索引的一部分，附加索引保存的是主索引的值。 
5. **是否支持数据库异常崩溃后的安全恢复** ：MyISAM 不支持，而 InnoDB 支持。 使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。
6. **外键支持**：MyISAM不支持外键；InnoDB支持外键。

#### 2.3.2 MyISAM 和 InnoDB 如何选择？

选 InnoDB





## 三、MySQL 索引

### 3.1 对于mysql索引的理解

索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

索引的优点主要有以下几条：

1. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快数据的查询速度，这也是创建索引的主要原因。

增加索引也有许多不利的方面，主要表现在如下几个方面：

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。
2. 索引需要占磁盘空间。

### 3.2 索引的数据结构

MySQL的默认的存储引擎InnoDB采用的B+树的数据结构来存储索引，选择B+树而不是B树的主要的原因是：

+ 数据不放在非叶子节点上，全部放在叶子节点上，非叶子结点可以放更多的索引信息，所以在磁盘IO操作时，每次读写的数据块可以更有效地使用，减少磁盘读写次数。
+ 叶子节点连成了一个循环链表 ，方便范围查询。

### 3.3 常见的索引

#### 3.3.1 主键索引

数据表的主键列使用的就是主键索引。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

#### 3.3.2 二级索引

二级索引（Secondary Index）的叶子节点存储的数据是主键的值，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引/非主键索引。

#### 3.3.3 聚簇索引与非聚簇索引

**聚簇索引:**（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

**非聚簇索引:**(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

#### 3.3.4 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 **覆盖索引（Covering Index）** 。如果不是覆盖索引，那么就需要回表查询。

在 InnoDB 存储引擎中，非主键索引的叶子节点包含的是主键的值。这意味着，当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。**



### 3.4 索引下推

索引条件下推优化 （Index Condition Pushdown (ICP) ） 是MySQL5.6添加 的，用于优化数据查询。 

+ 不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL Server，MySQL Server进行剩余的条件判断。 
+ 当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server将这一部分判断条件 下推 给存储引擎，然后由存储引擎通过判断索引是否 符合MySQL Server传递的条件，只有当索引符合条件时才会将数据检索出来返回 给MySQL服务器。

索引下推优化可以减少存储引擎回表的次数，也可以减少MySQL服务器和存储引擎传输的数据量。

### 3.5 索引失效的原因

+ or语句：若是or条件中有一个没有索引，那么就不走索引。
+ 如果字段类型是字符串，where时一定用引号括起来，否则会因为隐式类型转换，索引失效 
+ 模糊查询，如果%号在前面也会导致索引失效。 
+ 联合索引，在使用的时候没有遵循最左匹配法则，导致失效；
+ 在索引列上使用mysql的内置函数或者运算，索引失效。；

通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用explain执行计划来分析

### 3.6 创建索引的原则

+ 索引应该建在查询应用频繁的字段； 
+ 索引的个数应该适量，索引需要占用空间，更新时候也需要维护； 
+ 区分度低的字段，例如性别，不要建索引； 
+ 频繁更新的值，不要作为索引； 
+ 尽可能创建组合索引，而不是单列索引。 



## 四、MySQL 事务



## 五、MySQL 锁



## 六、MySQL 优化



### 2.1 慢查询

#### 2.1.1 定位慢查询

一般来说有两种方式：

1. 使用运维工具（例如 Skywalking、Prometheus 等）来监测接口的执行时间，并且可以分析接口中那部分执行较慢，来定位是否为sql执行过慢。
2. 还可以在测试环境下，开启mysql的慢日志查询，可以记录执行时间超过阈值的sql 到慢查询日志中。

其实在我们的项目中定位慢查询，主要就是测试的时候接口响应时间过长，然后把接口中的sql语句直接拿到数据库工具中执行一下，看看耗时，就可以定位了。不过我也了解过oracle定位慢查询的方式，主要是通过从动态性能视图(V$SQLAREA)中查询sql的执行时间、次数、语句信息来定位慢sql。但是主要的定位慢查询的方式还是运维检测工具。

